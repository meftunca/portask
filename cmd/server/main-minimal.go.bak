package main

import (
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/meftunca/portask/pkg/amqp"
	"github.com/meftunca/portask/pkg/api"
	"github.com/meftunca/portask/pkg/compression"
	"github.com/meftunca/portask/pkg/config"
	portaskjson "github.com/meftunca/portask/pkg/json"
	"github.com/meftunca/portask/pkg/queue"
	"github.com/meftunca/portask/pkg/serialization"
)

func main() {
	// Load configuration
	cfg, err := config.LoadConfig("configs/config.yaml")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	log.Printf("üöÄ Starting Portask v1.0.0 - Ultra Minimal Production Mode")

	// Initialize serialization (minimal)
	codecFactory := serialization.NewCodecFactory()
	if err := codecFactory.InitializeDefaultCodecs(cfg); err != nil {
		log.Fatalf("Failed to initialize codecs: %v", err)
	}
	codec, err := codecFactory.GetCodec(cfg.Serialization.Type)
	if err != nil {
		log.Fatalf("Failed to create codec: %v", err)
	}

	// Initialize compression (minimal)
	compressorFactory := compression.NewCompressorFactory()
	if err := compressorFactory.InitializeDefaultCompressors(cfg); err != nil {
		log.Fatalf("Failed to initialize compressors: %v", err)
	}
	compressor, err := compressorFactory.GetCompressor(cfg.Compression.Type)
	if err != nil {
		log.Fatalf("Failed to create compressor: %v", err)
	}

	// Use simple in-memory storage to avoid connection overhead
	log.Printf("üì¶ Using in-memory storage for ultra-minimal setup")
	storageBackend := NewInMemoryStore()

	// Initialize message processor (minimal)
	processor := queue.NewDefaultMessageProcessor(codec, compressor)

	// Configure message bus with MINIMAL resources
	busConfig := queue.MessageBusConfig{
		HighPriorityQueueSize:   100, // Very small queues
		NormalPriorityQueueSize: 1000,
		LowPriorityQueueSize:    500,
		DropPolicy:              queue.DropOldest,
		WorkerPoolConfig: queue.WorkerPoolConfig{
			WorkerCount:      2, // Only 2 workers!
			MessageProcessor: processor,
			BatchSize:        10,                     // Small batches
			BatchTimeout:     100 * time.Millisecond, // Longer timeout
			EnableProfiling:  false,                  // No profiling
		},
		EnableTopicQueues: false, // Disable topic queues for now
	}

	// Create and start message bus
	messageBus := queue.NewMessageBus(busConfig)
	if err := messageBus.Start(); err != nil {
		log.Fatalf("Failed to start message bus: %v", err)
	}
	defer messageBus.Stop()

	log.Printf("‚úÖ Message bus started with 2 workers")

	// Create protocol adapters
	amqpStore := &AMQPStorageAdapter{storage: storageBackend, messageBus: messageBus}

	// Start RabbitMQ-compatible server
	rabbitmqAddr := fmt.Sprintf(":%d", cfg.Network.RabbitMQPort)
	rabbitmqServer := amqp.NewEnhancedAMQPServer(rabbitmqAddr, amqpStore)
	go func() {
		log.Printf("üê∞ Starting RabbitMQ server on %s", rabbitmqAddr)
		if err := rabbitmqServer.Start(); err != nil {
			log.Printf("‚ö†Ô∏è  RabbitMQ server error: %v", err)
		}
	}()
	defer rabbitmqServer.Stop()

	// Start Kafka-compatible server
	kafkaAddr := fmt.Sprintf(":%d", cfg.Network.KafkaPort)
	kafkaStore := &KafkaStorageAdapter{storage: storageBackend, messageBus: messageBus}
	kafkaServer := NewKafkaServer(kafkaAddr, kafkaStore)
	go func() {
		log.Printf("üîó Starting Kafka server on %s", kafkaAddr)
		if err := kafkaServer.Start(); err != nil {
			log.Printf("‚ö†Ô∏è  Kafka server error: %v", err)
		}
	}()
	defer kafkaServer.Stop()

	// Start Fiber v2 HTTP API Server
	fiberConfig := api.FiberConfig{
		EnableCORS:      false, // Disable CORS
		EnableLogger:    false, // Disable request logging
		EnableRecover:   true,
		EnableRequestID: false, // Disable request ID
		JSONConfig: portaskjson.Config{
			Library:    portaskjson.JSONLibrary(cfg.Serialization.Type),
			Compact:    true,
			EscapeHTML: false,
		},
	}

	fiberServer := api.NewFiberServer(fiberConfig, nil, storageBackend)
	go func() {
		log.Printf("‚ö° Starting minimal API server on :8080")
		if err := fiberServer.Start(); err != nil {
			log.Printf("‚ö†Ô∏è  API server error: %v", err)
		}
	}()
	defer fiberServer.Stop()

	// NO PERFORMANCE MONITORING - This was causing high CPU!
	// NO DEMO MESSAGE GENERATION - This was also causing high CPU!

	log.Printf("‚úÖ Portask started in ultra-minimal mode:")
	log.Printf("   üîó Kafka: %d", cfg.Network.KafkaPort)
	log.Printf("   üê∞ RabbitMQ: %d", cfg.Network.RabbitMQPort)
	log.Printf("   ‚ö° API: 8080")
	log.Printf("   üë• Workers: 2 (minimal)")
	log.Printf("   ‚èπÔ∏è  Press Ctrl+C to stop")

	// Wait for shutdown signal
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	log.Printf("üõë Shutting down Portask...")

	// Cleanup storage
	if err := storageBackend.Close(); err != nil {
		log.Printf("‚ö†Ô∏è  Error closing storage: %v", err)
	}

	log.Printf("üëã Portask stopped gracefully")
}
